package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.48

import (
	"context"
	"errors"
	"os"
	"os/exec"
	"strings"
	"time"

	"github.com/fatih/color"
	"github.com/swiftwave-org/swiftwave/swiftwave_service/core"
	"github.com/swiftwave-org/swiftwave/swiftwave_service/graphql/model"
	"github.com/swiftwave-org/swiftwave/swiftwave_service/logger"
	swiftwaveServiceManagerDocker "github.com/swiftwave-org/swiftwave/swiftwave_service/manager"
	"gorm.io/gorm"
)

// CreateServer is the resolver for the createServer field.
func (r *mutationResolver) CreateServer(ctx context.Context, input model.NewServerInput) (*model.Server, error) {
	server := newServerInputToDatabaseObject(&input)
	err := core.CreateServer(&r.ServiceManager.DbClient, server)
	if err != nil {
		return nil, err
	}
	// if localhost, insert public key
	if server.IsLocalhost() {
		publicKey, err := r.Config.SystemConfig.PublicSSHKey()
		if err != nil {
			logger.GraphQLLoggerError.Println("Failed to generate public ssh key", err.Error())
		}
		// append the public key to current server ~/.ssh/authorized_keys
		err = AppendPublicSSHKeyLocally(publicKey)
		if err != nil {
			logger.GraphQLLoggerError.Println("Failed to append public ssh key", err.Error())
		}
	}
	return serverToGraphqlObject(server), nil
}

// DeleteServer is the resolver for the deleteServer field.
func (r *mutationResolver) DeleteServer(ctx context.Context, id uint) (bool, error) {
	// Checks -
	// 1. If server status `need_setup`, delete it from database
	// 2. If server status `preparing`, it can't be deleted
	// 3. If it's the last server, then delete it from db
	// 4. This should be swarm worker node
	// 5. Should disable ingress proxy on this server
	// 6. There should be another swarm manager running
	// 7. Remove from swarm cluster
	// 8. Remove from the database

	server, err := core.FetchServerByID(&r.ServiceManager.DbClient, id)
	if err != nil {
		return false, err
	}
	// If `need_setup`, delete it from database
	if server.Status == core.ServerNeedsSetup {
		err = core.DeleteServer(&r.ServiceManager.DbClient, id)
		if err != nil {
			return false, err
		}
		return true, nil
	}
	// If `preparing`, it can't be deleted
	if server.Status == core.ServerPreparing {
		return false, errors.New("server is preparing, you can delete it only after it come out of `preparing` status")
	}
	// If it's the last server, then delete it from db
	servers, err := core.FetchAllServers(&r.ServiceManager.DbClient)
	if err != nil {
		return false, err
	}
	if len(servers) == 1 {
		err = core.DeleteServer(&r.ServiceManager.DbClient, id)
		if err != nil {
			return false, err
		}
		return true, nil
	}
	// if not the last server, then required additional steps
	if server.SwarmMode == core.SwarmManager {
		return false, errors.New("from 'Actions' menu, demote this server to 'Swarm Worker' mode to proceed for deletion")
	}
	if server.ProxyConfig.Enabled {
		return false, errors.New("from 'Actions' menu, disable ingress proxy on this server to proceed for deletion")
	}
	// fetch another swarm manager
	otherSwarmManager, err := core.FetchSwarmManagerExceptServer(&r.ServiceManager.DbClient, id)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return false, errors.New("no other swarm manager found to proceed for deletion")
		}
	}
	// fetch docker manager
	dockerManager, err := swiftwaveServiceManagerDocker.DockerClient(ctx, otherSwarmManager)
	if err != nil {
		return false, err
	}
	// remove from swarm cluster
	err = dockerManager.RemoveNode(server.HostName)
	if err != nil {
		return false, err
	}
	// remove from local database
	err = core.DeleteServer(&r.ServiceManager.DbClient, id)
	if err != nil {
		return false, err
	}
	return true, nil
}

// FetchAnalyticsServiceToken is the resolver for the fetchAnalyticsServiceToken field.
func (r *mutationResolver) FetchAnalyticsServiceToken(ctx context.Context, id uint, rotate bool) (string, error) {
	var tokenRecord *core.AnalyticsServiceToken
	var err error
	if !rotate {
		tokenRecord, err = core.FetchAnalyticsServiceToken(ctx, r.ServiceManager.DbClient, id)
	} else {
		tokenRecord, err = core.RotateAnalyticsServiceToken(ctx, r.ServiceManager.DbClient, id)
	}
	if err != nil {
		return "", err
	} else {
		return tokenRecord.IDToken()
	}
}

// ChangeServerIPAddress is the resolver for the changeServerIpAddress field.
func (r *mutationResolver) ChangeServerIPAddress(ctx context.Context, id uint, ip string) (bool, error) {
	server, err := core.FetchServerByID(&r.ServiceManager.DbClient, id)
	if err != nil {
		return false, err
	}
	ip = strings.TrimSpace(ip)
	if len(ip) == 0 {
		return false, errors.New("IP is required")
	}
	if strings.Compare(server.IP, ip) == 0 {
		return false, errors.New("IP is already " + server.IP)
	}
	err = core.ChangeServerIP(&r.ServiceManager.DbClient, server, ip)
	if err != nil {
		return false, err
	}
	// Exit process
	logger.GraphQLLoggerError.Println("Server " + server.HostName + " IP changed to " + ip + "\nRestarting swiftwave in 2 seconds to take effect")
	// Restart swiftwave service
	go func() {
		<-time.After(2 * time.Second)
		color.Green("Restarting swiftwave service")
		color.Yellow("Swiftwave service will be restarted in 2 seconds")
		color.Yellow("If you are running without enabling service, run `swiftwave start` to start the service")
		_ = exec.Command("systemctl", "restart", "swiftwave.service").Run()
		os.Exit(0)
	}()
	return true, nil
}

// NoOfServers is the resolver for the noOfServers field.
func (r *queryResolver) NoOfServers(ctx context.Context) (int, error) {
	return core.NoOfServers(&r.ServiceManager.DbClient)
}

// NoOfPreparedServers is the resolver for the noOfPreparedServers field.
func (r *queryResolver) NoOfPreparedServers(ctx context.Context) (int, error) {
	return core.NoOfPreparedServers(&r.ServiceManager.DbClient)
}

// Servers is the resolver for the servers field.
func (r *queryResolver) Servers(ctx context.Context) ([]*model.Server, error) {
	servers, err := core.FetchAllServers(&r.ServiceManager.DbClient)
	if err != nil {
		return nil, err
	}
	serverList := make([]*model.Server, 0)
	for _, server := range servers {
		serverList = append(serverList, serverToGraphqlObject(&server))
	}
	return serverList, nil
}

// Server is the resolver for the server field.
func (r *queryResolver) Server(ctx context.Context, id uint) (*model.Server, error) {
	server, err := core.FetchServerByID(&r.ServiceManager.DbClient, id)
	if err != nil {
		return nil, err
	}
	return serverToGraphqlObject(server), nil
}

// ServerResourceAnalytics is the resolver for the serverResourceAnalytics field.
func (r *queryResolver) ServerResourceAnalytics(ctx context.Context, id uint, timeframe model.ServerResourceAnalyticsTimeframe) ([]*model.ServerResourceAnalytics, error) {
	var previousTime = time.Now()
	switch timeframe {
	case model.ServerResourceAnalyticsTimeframeLast1Hour:
		previousTime = time.Now().Add(-1 * time.Hour)
	case model.ServerResourceAnalyticsTimeframeLast3Hours:
		previousTime = time.Now().Add(-3 * time.Hour)
	case model.ServerResourceAnalyticsTimeframeLast6Hours:
		previousTime = time.Now().Add(-6 * time.Hour)
	case model.ServerResourceAnalyticsTimeframeLast12Hours:
		previousTime = time.Now().Add(-12 * time.Hour)
	case model.ServerResourceAnalyticsTimeframeLast24Hours:
		previousTime = time.Now().Add(-24 * time.Hour)
	case model.ServerResourceAnalyticsTimeframeLast7Days:
		previousTime = time.Now().Add(-7 * 24 * time.Hour)
	case model.ServerResourceAnalyticsTimeframeLast30Days:
		previousTime = time.Now().Add(-30 * 24 * time.Hour)
	}
	previousTimeUnix := previousTime.Unix()

	// fetch the server resource analytics
	serverResourceStat, err := core.FetchServerResourceAnalytics(ctx, r.ServiceManager.DbClient, id, uint(previousTimeUnix))
	if err != nil {
		return nil, err
	}
	// convert the server resource analytics to graphql object
	serverResourceStatList := make([]*model.ServerResourceAnalytics, 0)
	for _, record := range serverResourceStat {
		serverResourceStatList = append(serverResourceStatList, serverResourceStatToGraphqlObject(record))
	}
	return serverResourceStatList, nil
}

// ServerDiskUsage is the resolver for the serverDiskUsage field.
func (r *queryResolver) ServerDiskUsage(ctx context.Context, id uint) ([]*model.ServerDisksUsage, error) {
	// fetch the server disk usage
	serverResourceUsageRecords, err := core.FetchServerDiskUsage(ctx, r.ServiceManager.DbClient, id)
	if err != nil {
		return nil, err
	}
	serverDiskStatsList := make([]*model.ServerDisksUsage, 0)
	for _, record := range serverResourceUsageRecords {
		val := severDisksStatToGraphqlObject(record.DiskStats, record.RecordedAt)
		serverDiskStatsList = append(serverDiskStatsList, &val)
	}
	return serverDiskStatsList, nil
}

// ServerLatestResourceAnalytics is the resolver for the serverLatestResourceAnalytics field.
func (r *queryResolver) ServerLatestResourceAnalytics(ctx context.Context, id uint) (*model.ServerResourceAnalytics, error) {
	// fetch the latest server resource analytics
	serverResourceStat, err := core.FetchLatestServerResourceAnalytics(ctx, r.ServiceManager.DbClient, id)
	if err != nil {
		return nil, err
	}
	// convert the server resource analytics to graphql object
	return serverResourceStatToGraphqlObject(serverResourceStat), nil
}

// ServerLatestDiskUsage is the resolver for the serverLatestDiskUsage field.
func (r *queryResolver) ServerLatestDiskUsage(ctx context.Context, id uint) (*model.ServerDisksUsage, error) {
	// fetch the latest server disk usage
	serverDiskStats, timestamp, err := core.FetchLatestServerDiskUsage(ctx, r.ServiceManager.DbClient, id)
	if err != nil {
		return nil, err
	}
	// convert the server disk usage to graphql object
	res := severDisksStatToGraphqlObject(*serverDiskStats, *timestamp)
	return &res, nil
}

// SwarmNodeStatus is the resolver for the swarmNodeStatus field.
func (r *serverResolver) SwarmNodeStatus(ctx context.Context, obj *model.Server) (string, error) {
	server, err := core.FetchServerByID(&r.ServiceManager.DbClient, obj.ID)
	if err != nil {
		return "", nil
	}
	if server.Status != core.ServerOnline {
		return "", nil
	}
	// Fetch any swarm manager
	swarmManagerServer, err := core.FetchSwarmManager(&r.ServiceManager.DbClient)
	if err != nil {
		return "", nil
	}
	manager, err := swiftwaveServiceManagerDocker.DockerClient(ctx, swarmManagerServer)
	if err != nil {
		return "", nil
	}
	return manager.FetchNodeStatus(server.HostName)
}

// Logs is the resolver for the logs field.
func (r *serverResolver) Logs(ctx context.Context, obj *model.Server) ([]*model.ServerLog, error) {
	serverLogs, err := core.FetchServerLogByServerID(&r.ServiceManager.DbClient, obj.ID)
	if err != nil {
		return nil, err
	}
	serverLogList := make([]*model.ServerLog, 0)
	for _, serverLog := range serverLogs {
		serverLogList = append(serverLogList, serverLogToGraphqlObject(&serverLog))
	}
	return serverLogList, nil
}

// Server returns ServerResolver implementation.
func (r *Resolver) Server() ServerResolver { return &serverResolver{r} }

type serverResolver struct{ *Resolver }
